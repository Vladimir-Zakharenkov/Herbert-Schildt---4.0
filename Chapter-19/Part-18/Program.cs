// Методы запроса

// Синтаксис запроса, описанный в предыдущих разделах, применяется при формировании
// большинства запросов в С#. Он удобен, эффективен и компактен, хотя и не
// является единственным способом формирования запросов. Другой способ состоит
// в использовании методов запроса, которые могут вызываться для любого перечислимого
// объекта, например массива.

// Основные методы запроса

// Методы запроса определяются в классе System.Linq.Enumerable и реализуются
// в виде методов расширения функций обобщенной формы интерфейса IEnumerable<T>.
// (Методы запроса определяются также в классе System.Linq.Queryable, расширяющем
// функции обобщенной формы интерфейса IQueryable<T>, но этот интерфейс
// в настоящей главе не рассматривается.) Метод расширения дополняет функции другого
// класса, но без наследования. Поддержка методов расширения была внедрена в версию
// C# 3.0 и более подробно рассматривается далее в этой главе. А до тех пор достаточно
// сказать, что методы запроса могут вызываться только для тех объектов, которые
// реализуют интерфейс IEnumerable<T>.

// В классе Enumerable предоставляется немало методов запроса, но основными считаются
// те методы, которые соответствуют описанным ранее операторам запроса. Эти
// методы перечислены ниже вместе с соответствующими операторами запроса. Следует,
// однако, иметь в виду, что эти методы имеют также перегружаемые формы, а здесь они
// представлены лишь в самой простой своей форме. Но именно эта их форма используется
// чаще всего.

// Оператор запроса     Эквивалентный метод запроса
// select               Select(selector)
// where                Where(predicate)
// orderby              OrderBy(keySelector) или OrderByDescending(keySelector)
// join                 Join(inner, outerKeySelector, innerKeySelector, resultSelector)
// group                GroupBy(keySelector)


// За исключением метода Join(), остальные методы запроса принимают единственный
// аргумент, который представляет собой объект некоторой разновидности
// обобщенного типа Func<T, TResult>.Это тип встроенного делегата, объявляемый
// следующим образом:

// delegate TResult Func<in Т, out TResult>(T arg)

// где TResult обозначает тип результата, который дает делегат, а Т — тип элемента.
// В методах запроса аргументы selector, predicate или keySelector определяют
// действие, которое предпринимает метод запроса. Например, в методе Where() аргумент
// prediсаte определяет порядок отбора данных в запросе. Каждый метод запроса
// возвращает перечислимый объект. Поэтому результат выполнения одного метода запроса
// можно использовать для вызова другого, соединяя эти методы в цепочку.

// Метод Join() принимает четыре аргумента. Первый аргумент (inner) представляет
// собой ссылку на вторую объединяемую последовательность, а первой является последовательность,
// для которой вызывается метод Join(). Селектор ключа для первой последовательности
// передается в качестве аргумента outerKeySelector, а селектор ключа для
// второй последовательности — в качестве аргумента LnnerKeySelector. Результат объединения
// обозначается как аргумент resultSelector. Аргумент outerKeySelector
// имеет тип Func<TOuter, ТКеу>, аргумент innerKeySelector — тип Func<TInner, ТКеу>,
// тогда как аргумент resultSelector — тип Func<TOuter, Tinner, TResult>,
// где TOuter — тип элемента из вызывающей последовательности; Tinner — тип элемента
// из передаваемой последовательности; TResult — тип элемента из объединяемой
// в итоге последовательности, возвращаемой в виде перечислимого объекта.

// Аргумент метода запроса представляет собой метод, совместимый с указываемой
// формой делегата Func, но он не обязательно должен быть явно объявляемым методом.
// На самом деле вместо него чаще всего используется лямбда-выражение. Как пояснялось
// в главе 15, лямбда-выражение обеспечивает более простой, но эффективный
// способ определения того, что, по существу, является анонимным методом, а компилятор
// C# автоматически преобразует лямбда-выражение в форму, которая может быть
// передана в качестве параметра делегату Func. Благодаря тому что лямбда-выражения
// обеспечивают более простой и рациональный способ программирования, они используются
// во всех примерах, представленных далее в этом разделе.

// Формирование запросов с помощью методов запроса

// Используя методы запроса одновременно с лямбда-выражениями, можно формировать
// запросы, вообще не пользуясь синтаксисом, предусмотренным в C# для запросов.
// Вместо этого достаточно вызвать соответствующие методы запроса. Обратимся
// сначала к простому примеру. Он представляет собой вариант первого примера программы
// из этой главы, переделанный с целью продемонстрировать применение методов
// запроса Where() и Select() вместо соответствующих операторов.

//Использовать методы запроса для формирования простого запроса.
//Это переделанный вариант первого примера программы из настоящей главы.
using System;
using System.Linq;

class SimpQuery
{
    static void Main()
    {
        int[] nums = { 1, -2, 3, 0, -4, 5 };

        //Использовать методы Where() и Select()
        //для формирования простого запроса.
        var posNums = nums.Where(n => n > 0).Select(r => r);

        Console.Write("Положительные знаачения из массива nums: ");

        //Выполнить запрос и вывести его результаты.
        foreach(int i in posNums)
        {
            Console.Write(" " + i);
        }

        Console.WriteLine();

        //Задержка программы.
        Console.ReadKey();
    }
}

// Эта версия программы дает такой же результат, как и исходная.

// Положительные значения из массива nums: 1 3 5

// Обратите особое внимание в данной программе на следующую строку кода.

// var posNums = nums.Where(n => n > 0).Select(r => r);

// В этой строке кода формируется запрос, сохраняемый в переменной posNums. По
// этому запросу, в свою очередь, формируется последовательность положительных значений,
// извлекаемых из массива nums. Для этой цели служит метод Where(), отбирающий
// запрашиваемые значения, а также метод Select(), избирательно формирующий
// из этих значений окончательный результат. Метод Where() может быть вызван для
// массива nums, поскольку во всех массивах реализуется интерфейс IEnumerable<T>,
// поддерживающий методы расширения запроса.

// Формально метод Select() в рассматриваемом здесь примере не нужен, поскольку
// это простой запрос. Ведь последовательность, возвращаемая методом Where(), уже
// содержит конечный результат. Но окончательный выбор можно сделать и по более
// сложному критерию, как это было показано ранее на примерах использования синтаксиса
// запросов. Так, по приведенному ниже запросу из массива nums возвращаются
// положительные значения, увеличенные на порядок величины.

// var posNums = nums.Where(n => n > 0).Select(r => r * 10);

// Как и следовало ожидать, в цепочку можно объединять и другие операции над данными,
// получаемыми по запросу. Например, по следующему запросу выбираются положительные
// значения, которые затем сортируются по убывающей и возвращаются в
// виде результирующей последовательности:

// var posNums = nums.Where(n => n > 0).OrderByDescending(j => j);

// где выражение j => j обозначает, что упорядочение зависит от входного параметра,
// который является элементом данных из последовательности, получаемой из метода Where().