// Именованные аргументы

// Еще одним средством, связанным с передачей аргументов методу, является именованный
// аргумент. Именованные аргументы были внедрены в версии C# 4.0. Как вам
// должно быть уже известно, при передаче аргументов методу порядок их следования,
// как правило, должен совпадать с тем порядком, в котором параметры определены в
// самом методе. Иными словами, значение аргумента присваивается параметру по его
// позиции в списке аргументов. Данное ограничение призваны преодолеть именованные
// аргументы. Именованный аргумент позволяет указать имя того параметра, которому
// присваивается его значение. И в этом случае порядок следования аргументов уже не
// имеет никакого значения. Таким образом, именованные аргументы в какой-то степени
// похожи на упоминавшиеся ранее инициализаторы объектов, хотя и отличаются от
// них своим синтаксисом.

// Для указания аргумента по имени служит следующая форма синтаксиса.

// имя_параметра : значение

// Здесь имя_параметра обозначает имя того параметра, которому передается значение.
// Разумеется, имя_параметра должно обозначать имя действительного параметра
// для вызываемого метода.

// Ниже приведен простой пример, демонстрирующий применение именованных
// аргументов. В этом примере создается метод IsFactor(), возвращающий логическое
// значение true, если первый его параметр нацело делится на второй параметр.

//Применить именованные аргументы.
using System;

class NamedArgsDemo
{
    //Выяснить, делится ли одно значение нацело на другое.
    static bool IsFactor(int val, int divisor)
    {
        if ((val % divisor == 0))
        {
            return true;
        }

        return false;
    }

    static void Main()
    {
        //Ниже демонстрируются разные способы вызова метода IsFactor().

        //Вызов с использованием позиционных аргументов.
        if (IsFactor(10, 2))
        {
            Console.WriteLine("2 - множитель 10.");
        }

        //Вызов с использованием именованных аргументов.
        if (IsFactor(val: 10, divisor: 2))
        {
            Console.WriteLine("2 - множитель 10.");
        }

        //Для именованного аргумента порядок указания не имеет значения.
        if (IsFactor(divisor: 2, val: 10))
        {
            Console.WriteLine("2 - множитель 10.");
        }

        //Применить как позиционный, так и именованный аргумент.
        if (IsFactor(10,divisor: 2))
        {
            Console.WriteLine("2 - множитель 10.");
        }

        //Задержка программы.
        Console.ReadKey();
    }
}

// Выполнение этого кода дает следующий результат.

// 2 - множитель 10.
// 2 - множитель 10.
// 2 - множитель 10.
// 2 - множитель 10.

// Как видите, при каждом вызове метода IsFactor() получается один и тот же результат.

// Помимо демонстрации именованного аргумента в действии, приведенный выше
// пример кода иллюстрирует две важные особенности именованных аргументов.
// Во-первых, порядок следования аргументов не имеет никакого значения. Например,
// два следующих вызова метода IsFactor() совершенно равнозначны.

// IsFactor(val :10, divisor: 2)
// IsFactor(divisor: 2, val: 10)

// Независимость от порядка следования является главным преимуществом именованных
// аргументов. Это означает, что запоминать (или даже знать) порядок следования
// параметров в вызываемом методе совсем не обязательно. Для работы с СОМ-
// интерфейсами это может быть очень удобно. И во-вторых, позиционные аргументы
// можно указывать вместе с именованными в одном и том же вызове, как показано в
// следующем примере.

// IsFactor(10, divisor: 2)

// Следует, однако, иметь в виду, что при совместном использовании именованных
// и позиционных аргументов все позиционные аргументы должны быть указаны перед
// любыми именованными аргументами.

// Именованные аргументы можно также применять вместе с необязательными аргументами.
// Покажем это на примере вызова метода Display(), рассматривавшегося в
// предыдущем разделе.

// //Указать все аргументы по имени.
// Display(stop: 10, str: "это простой тест", start: 0);

// //Сделать аргумент start устанавливаемым по умолчанию.
// Display(stop: 10, str: "это простой тест");

// // Указать строку по позиции, аргумент stop — по имени by name,
// // тогда как аргумент start — устанавливаемым по умолчанию
// Display("это простой тест", stop: 10);

// Вообще говоря, комбинация именованных и необязательных аргументов позволяет
// упростить вызовы сложных методов со многими параметрами.

// Синтаксис именованных аргументов более многословен, чем у обычных позиционных
// аргументов, и поэтому для вызова методов чаще всего применяются позиционные
// аргументы. Но в тех случаях, когда это уместно, именованные аргументы могут быть
// использованы довольно эффективно.

// ПРИМЕЧАНИЕ
// Помимо методов, именованные и необязательные аргументы могут применяться
// в конструкторах, индексаторах и делегатах. (Об индексаторах и делегатах речь пойдет далее
// в этой книге.)