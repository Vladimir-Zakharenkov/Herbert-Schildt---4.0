// Глава 8
// Подробнее о методах и классах

// В данной главе возобновляется рассмотрение классов
// и методов. Оно начинается с пояснения механизма
// управления доступом к членам класса. А затем обсуждаются
// такие вопросы, как передача и возврат объектов,
// перегрузка методов, различные формы метода Main(),
// рекурсия и применение ключевого слова static.

// Управление доступом к членам класса

// Поддержка свойства инкапсуляции в классе дает два
// главных преимущества. Во-первых, класс связывает данные
// с кодом. Это преимущество использовалось в предыдущих
// примерах программ, начиная с главы 6. И во-вторых, класс
// предоставляет средства для управления доступом к его членам.
// Именно эта, вторая преимущественная особенность
// и будет рассмотрена ниже.

// В языке С#, по существу, имеются два типа членов класса:
// открытые и закрытые, хотя в действительности дело обстоит
// немного сложнее. Доступ к открытому члену свободно
// осуществляется из кода, определенного за пределами
// класса. Именно этот тип члена класса использовался в рассматривавшихся
// до сих пор примерах программ. А закрытый
// член класса доступен только методам, определенным
// в самом классе. С помощью закрытых членов и организуется
// управление доступом.

// Ограничение доступа к членам класса является основополагающим
// этапом объектно-ориентированного программирования,
// поскольку позволяет исключить неверное
// использование объекта. Разрешая доступ к закрытым
// данным только с помощью строго определенного ряда методов, можно предупредить
// присваивание неверных значений этим данным, выполняя, например, проверку диапазона
// представления чисел. Для закрытого члена класса нельзя задать значение непосредственно
// в коде за пределами класса. Но в то же время можно полностью управлять
// тем, как и когда данные используются в объекте. Следовательно, правильно реализованный
// класс образует некий "черный ящик", которым можно пользоваться, но внутренний
// механизм его действия закрыт для вмешательства извне.

// Модификаторы доступа

// Управление доступом в языке C# организуется с помощью четырех модификаторов
// доступа: public, private, protected и internal. В этой главе основное внимание
// уделяется модификаторам доступа public и private. Модификатор protected применяется
// только в тех случаях, которые связаны с наследованием, и поэтому речь о нем
// пойдет в главе 11. А модификатор internal служит в основном для сборки, которая в
// широком смысле означает в C# разворачиваемую программу или библиотеку, и поэтому
// данный модификатор подробнее рассматривается в главе 16.

// Когда член класса обозначается спецификатором public, он становится доступным
// из любого другого кода в программе, включая и методы, определенные в других
// классах. Когда же член класса обозначается спецификатором private, он может быть
// доступен только другим членам этого класса. Следовательно, методы из других классов
// не имеют доступа к закрытому члену (private) данного класса. Как пояснялось в главе 6,
// если ни один из спецификаторов доступа не указан, член класса считается закрытым
// для своего класса по умолчанию.Поэтому при создании закрытых членов класса
// спецификатор private указывать для них необязательно.

// Спецификатор доступа указывается перед остальной частью описания типа отдельного
// члена.Это означает, что именно с него должен начинаться оператор объявления
// члена класса. Ниже приведены соответствующие примеры.

// public string errMsg;
// private double bal;
// private bool isError(byte status) { // ...

// Для того чтобы стали более понятными отличия между модификаторами public
// и private, рассмотрим следующий пример программы.

//Отличия между видами доступа public и private к членам класса.
using System;

class MyClass
{
    private int alpha;      //закрытый доступ, указываемый явно
    int beta;               //закрытый доступ по умолчанию
    public int gamma;       //открытый доступ

    //Методы, которым доступны члены alpha и beta данного класса.
    //Член класса может иметь доступ к закрытому члену этого же класса.

    public void SetAlpha(int a)
    {
        alpha = a;
    }

    public int GetAlpha()
    {
        return alpha;
    }

    public void SetBeta(int a)
    {
        beta = a;
    }

    public int GetBeta()
    {
        return beta;
    }
}

class AccessDemo
{
    static void Main()
    {
        MyClass ob = new MyClass();

        //Доступ к членам alpha и beta данного класса разрешен только посредством его методов.
        ob.SetAlpha(-99);
        ob.SetBeta(19);
        Console.WriteLine("ob.alpha равно " + ob.GetAlpha());
        Console.WriteLine("ob.beta равно " + ob.GetBeta());

        //Следующие виды доступа к членам alpha и beta данного класса не разрешаются.
        // ob.alpha = 10; // Ошибка! alpha - закрытый член!
        // ob.beta = 9; //  Ошибка! beta - закрытый член!

        //Член gamma данного класса доступен непосредственно, поскольку он является открытым.
        ob.gamma = 99;
        Console.WriteLine("ob.gamma равно {0}", ob.gamma);

        //Задержка программы.
        Console.ReadKey();
    }
}

// Как видите, в классе MyClass член alpha указан явно как private, член beta становится
// private по умолчанию, а член gamma указан как public. Таким образом,
// члены alpha и beta недоступны непосредственно из кода за пределами данного класса,
// поскольку они являются закрытыми. В частности, ими нельзя пользоваться непосредственно
// в классе AccessDemo. Они доступны только с помощью таких открытых
// (public) методов, как SetAlpha() и GetAlpha(). Так, если удалить символы комментария
// в начале следующей строки кода:

// // ob.alpha = 10; // Ошибка! alpha - закрытый член!

// то приведенная выше программа не будет скомпилирована из-за нарушения правил
// доступа. Но несмотря на то, что член alpha недоступен непосредственно за пределами
// класса MyClass, свободный доступ к нему организуется с помощью методов,
// определенных в классе MyClass, как наглядно показывают методы SetAlpha()
// и GetAlpha(). Это же относится и к члену beta.

// Из всего сказанного выше можно сделать следующий важный вывод: закрытый член
// может свободно использоваться другими членами этого же класса, но недоступен для
// кода за пределами своего класса.