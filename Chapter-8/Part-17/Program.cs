// И как пояснялось в главе 3, в C# предусмотрен ряд неявных (т.е. автоматических)
// преобразований типов. Эти преобразования распространяются также на параметры
// перегружаемых методов. В качестве примера рассмотрим следующую программу.

// Неявные преобразования типов могут повлиять на решение перегружать метод.
using System;

class Overload2
{
    public void MyMeth(int x)
    {
        Console.WriteLine("В методе MyMeth(int): " + x);
    }

    public void MyMeth(double x)
    {
        Console.WriteLine("В методе MyMeth(double): " + x);
    }
}

class TypeConv
{
    static void Main()
    {
        Overload2 ob = new Overload2();

        int i = 10;
        double d = 10.1;

        byte b = 99;
        short s = 10;
        float f = 11.5F;

        ob.MyMeth(i); //вызвать метод ob.MyMeth(int)
        ob.MyMeth(d); //вызвать метод MyMeth(double)

        ob.MyMeth(b); //вызвать метод ob.MyMeth(int) -- с преобразованием типа
        ob.MyMeth(s); //вызвать метод ob.MyMeth(int) -- с преобразованием типа
        ob.MyMeth(f); //вызвать метод ob.MyMeth(double) -- с преобразованием типа

        //Задержка программы.
        Console.ReadKey();
    }
}

// В данном примере определены только два варианта метода MyMeth(): с параметром
// типа int и с параметром типа double. Тем не менее методу MyMeth() можно
// передать значение типа byte, short или float. Так, если этому методу передается значение
// типа byte или short, то компилятор C# автоматически преобразует это значение
// в тип int и в итоге вызывается вариант MyMeth(int) данного метода. А если
// ему передается значение типа float, то оно преобразуется в тип double и в результате
// вызывается вариант MyMeth(double) данного метода.